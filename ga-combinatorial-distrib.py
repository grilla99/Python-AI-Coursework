# -*- coding: utf-8 -*-
"""
Complete this code for combinatorial optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt


# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 50 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 100 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CROSSOVER_RATE = 0.8 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.2 # Change MUTATION_RATE to obtain better fitness.

LOWER_BOUND = -10
UPPER_BOUND = 10
FITNESS_CHOICE = 1

NO_OF_GENES = 8
NO_OF_PARENTS = 8

FITNESS_DICTIONARY = {
    1: "Sum 1s (Minimisation)",
    2: "Sum 1s (Maximisation)"
}


def generate_population(size):
    
    population = [[random.randint(0, 1) for _ in range(NO_OF_GENES)] for _ in range(POPULATION_SIZE)]
    
    return population

def compute_fitness(individual):
    fitness_Function = {
        1: sum_ones,
        2: sum_ones,
    }


def sum_ones(individual):
    fitness = 0
    digit_to_match = 1 #TODO: Make this change depending on if it's a min or maximisation function

    for x in individual:
        if x == digit_to_match:
            fitness += 1

    return fitness





def compute_fitness(individual):
    #TODO : Write your own code to generate fitness function evaluation for your select functions
    print('fitness computed')
    fitness = np.nan()
    return fitness


def selection(population):

    individual = []  # Update this line if you need to
    #TODO : Write your own code to for choice  of your selection operator
    
    return individual
    

def crossover(first_parent, second_parent):
    
    individual = [] # Update this line if you need to
    #TODO : Write your own code to for choice  of your crossover operator - you can use if condition to write more tan one ime of crossover operator
    
    return individual

def mutation(individual):
    
    #TODO : Write your own code to for choice  of your mutation operator - you can use if condition to write more tan one ime of crossover operator
    

    return individual

#TODO : You can increase number of function to be used to improve your GA code 




def next_generation(previous_population):
    #TODO : Write your own code to generate next 
    
    
    print(' ') # Print appropriate generation information here. 
    return next_generation
    

# USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMOND LINE   
def main(): 
    global POPULATION_SIZE 
    global GENERATIONS
    global SOLUTION_FOUND
    
    population = generate_population(POPULATION_SIZE)
    
    
    print('complete code for a combinitorial optimization problem:')
    while (True):  # TODO: write your termination condition here or within the loop 
        #TODO: write your generation propagation code here 


        #TODO: present innovative graphical illustration like plots and presentation of genetic algorithm results 
        #This is free (as you like) innovative part of the assessment.
        break # Remove this line
 

if __name__ == '__main__': 
    main() 
    
    
    
