# -*- coding: utf-8 -*-
"""
Complete this code for combinatorial optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random, string
import math
import numpy as np
import matplotlib as plt

from math import cos, pi, sin,sqrt

# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 50 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 100 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CROSSOVER_RATE = 0.8 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.2 # Change MUTATION_RATE to obtain better fitness.

LOWER_BOUND = -10
UPPER_BOUND = 10
FITNESS_CHOICE = 1

NO_OF_GENES = 8
NO_OF_PARENTS = 8

KNAPSACK = {}
KNAPSACK_WEIGHT_THRESHOLD = 35


FITNESS_DICTIONARY = {
    1: "Sum 1s (Minimisation)",
    2: "Sum 1s (Maximisation)",
    3: "String matching",
    4: "Reaching a number",
    5: "Knapsack problem"
}


def generate_population(size):
    if FITNESS_CHOICE == 1 or FITNESS_CHOICE == 2:
        population = [[random.randint(0, 1) for _ in range(NO_OF_GENES)] for _ in range(POPULATION_SIZE)]
    elif FITNESS_CHOICE == 3:
        # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~0123456789
        terms = string.ascii_letters + string.punctuation + string.digits
        population = [[''.join(random.choice(terms) for _ in range(NO_OF_GENES))] for _ in range(POPULATION_SIZE)]

    return population


def compute_fitness(individual):
    fitness_function = {
        1: sum_ones,
        2: sum_ones,
        3: match_string,
        4: reach_number,
        5: knapsack_problem,
    }

    fitness_func = fitness_function.get(FITNESS_CHOICE)

    return fitness_func(individual)

def sum_ones(individual):
    fitness = 0
    digit_to_match = 1 #TODO: Make this change depending on if it's a min or maximisation function

    for x in individual:
        if x == digit_to_match:
            fitness += 1

    return fitness


def match_string(individual):
    fitness = 0
    string_to_match = 'An8Digit'

    for x, y in zip(individual, string_to_match):
        if x == y:
            fitness += 1
    try:
        fitness = (1 / abs(fitness) * 100)
    except ZeroDivisionError:
        fitness = float('inf')
    return fitness


def reach_number(individual):
    fitness = 0

    number_to_reach = 100

    fitness = number_to_reach - sum(individual)

    try:
        fitness = (1 / abs(fitness) * 100)
    except ZeroDivisionError:
        fitness = float('inf')
    return fitness


# https://www.youtube.com/watch?v=MacVqujSXWE
# https://medium.com/koderunners/genetic-algorithm-part-3-knapsack-problem-b59035ddd1d6
def knapsack_problem(individual):
    sack_weight = 0
    sack_value = 0

    for x in range(len(individual)):
        if individual[x] == 1:
            sack_weight += KNAPSACK[x][0]
            sack_value += KNAPSACK[x][1]

    # If the bag exceeds the threshold weight, then isn't an acceptable solution
    # So the function will return 0 to signify thiss
    if sack_weight > KNAPSACK_WEIGHT_THRESHOLD:
        return 0
    else:
        return sack_value

def selection(population,fitness, no_of_parents):
    parents = np.empty(NO_OF_PARENTS, NO_OF_GENES)

    #Declaration required to avoid referenced before assignment error

    positive_fitness = fitness.copy()

    # Roulette Wheel Selection Operator

    if (sum(i < 0 for i in fitness) != 0):
        positive_fitness = [fitness[x] + abs(min(fitness)) + 1 for x in range(len(fitness))]

    total_fitness = sum(positive_fitness)

    try:
        relative_fitness = [(n / total_fitness) for n in positive_fitness]
        roulette_indices = np.random.choice(range(0, POPULATION_SIZE), size=NO_OF_PARENTS, replace=False,
                                            p=relative_fitness)
    except ZeroDivisionError:
        print("Population fitness of 0")
        return False

    parents = [population[x] for x in roulette_indices]

    return parents
    

def crossover(parents, num_of_offspring):
    offspring = np.empty((num_of_offspring, NO_OF_GENES))

    for i in range(num_of_offspring):
        parent1_index = i%NO_OF_PARENTS
        parent2_index = (i+1)%NO_OF_PARENTS

        if random.random() < CROSSOVER_RATE:
            offspring[i] = list(parents[parent1_index][0:4]) + list(parents[parent2_index][4:9])
        else:
            offspring[i] = list(parents[parent1_index])

    return offspring

def mutation(offspring):

    # Scramble mutation for BINARY
    if random.random() < MUTATION_RATE:
        no_of_mutations = random.randint(0, NO_OF_GENES / 2)
        affected_gene = random.randint(0, NO_OF_GENES / 2)

        if no_of_mutations >= 1:
            for x in range(no_of_mutations):
                ## Swaps the 0 to 1 and 1 to 0.
                offspring[affected_gene + x] = 1 - offspring[affected_gene + x]

        elif True: #TODO: This needs to be changed to if it's a alphanumeric string
            terms = string.ascii_letters + string.punctuation + string.digits
            offspring[affected_gene] = random.choice(terms)




    return offspring

#TODO : You can increase number of function to be used to improve your GA code 




def next_generation(previous_population):
    #TODO : Write your own code to generate next 
    
    
    print(' ') # Print appropriate generation information here. 
    return next_generation
    

# USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMOND LINE   
def main(): 
    global POPULATION_SIZE 
    global GENERATIONS
    global SOLUTION_FOUND
    
    population = generate_population(POPULATION_SIZE)

    if FITNESS_CHOICE == 5:
        for x in range(NO_OF_GENES):
            KNAPSACK[x] = (random.randint(1, 15), random.randint(0, 600))

    if FITNESS_CHOICE == 5:
        print('Knapsack List is as follows: ')
        for x in KNAPSACK:
            print("Item No: ", x, "Weight: ", KNAPSACK[x][0], "Value: ", KNAPSACK[x][1])

    print('complete code for a combinitorial optimization problem:')
    while (True):  # TODO: write your termination condition here or within the loop 
        #TODO: write your generation propagation code here 


        #TODO: present innovative graphical illustration like plots and presentation of genetic algorithm results 
        #This is free (as you like) innovative part of the assessment.
        break # Remove this line
 

if __name__ == '__main__': 
    main() 
    
    
    
